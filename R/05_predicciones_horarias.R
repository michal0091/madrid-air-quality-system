# PREDICCIONES HORARIAS PARA PR√ìXIMAS 40 HORAS
# Objetivo: Generar predicciones temporales cada hora con datos meteorol√≥gicos simulados

# 1. LIBRER√çAS ----
library(sf)
library(dplyr)
library(lubridate)
library(logger)
library(glue)

# 2. CONFIGURACI√ìN ----
log_appender(appender_tee("logs/predicciones_horarias.log"))
log_info("--- INICIO PREDICCIONES HORARIAS ---")

# 3. FUNCI√ìN PARA GENERAR DATOS METEOROL√ìGICOS FUTUROS ----
generar_meteo_futuro <- function(horas_futuras = 40) {
  
  log_info("Generando datos meteorol√≥gicos para pr√≥ximas {horas_futuras} horas...")
  
  # Punto de inicio: hora actual
  inicio <- Sys.time()
  inicio_hora <- floor_date(inicio, "hour")
  
  # Crear secuencia de horas futuras
  horas_seq <- seq(inicio_hora, by = "hour", length.out = horas_futuras)
  
  # Simular patr√≥n meteorol√≥gico realista para Madrid
  datos_meteo <- data.frame(
    fecha_hora = horas_seq,
    fecha = as.Date(horas_seq),
    hora = hour(horas_seq),
    dia_a√±o = yday(horas_seq)
  ) %>%
    mutate(
      # Patr√≥n de temperatura realista para Madrid seg√∫n √©poca del a√±o
      mes = month(fecha_hora),
      temp_base = case_when(
        mes %in% c(12, 1, 2) ~ 8,   # Invierno: 8¬∞C base
        mes %in% c(3, 4, 5) ~ 18,   # Primavera: 18¬∞C base
        mes %in% c(6, 7, 8) ~ 28,   # Verano: 28¬∞C base
        mes %in% c(9, 10, 11) ~ 18  # Oto√±o: 18¬∞C base
      ),
      temp_diurna = sin((hora - 6) * pi / 12) * 6, # Variaci√≥n diurna reducida (¬±6¬∞C)
      temp_media_c = temp_base + temp_diurna + rnorm(n(), 0, 1.5),
      
      # Humedad inversa a temperatura
      humedad_media_pct = 70 - (temp_media_c - 20) * 1.5 + rnorm(n(), 0, 5),
      
      # Precipitaci√≥n ocasional (10% probabilidad)
      precipitacion_mm = ifelse(runif(n()) < 0.1, rexp(n(), 2), 0),
      
      # Viento m√°s fuerte durante el d√≠a
      vel_viento_media_ms = 2 + sin((hora - 12) * pi / 12) * 1.5 + abs(rnorm(n(), 0, 0.5)),
      
      # Direcci√≥n del viento con variabilidad
      dir_viento_grados = 200 + sin(hora * pi / 12) * 30 + rnorm(n(), 0, 20),
      
      # Presi√≥n con variaci√≥n ligera
      presion_maxima_hpa = 1013 + sin((dia_a√±o - 50) * 2 * pi / 365) * 8 + rnorm(n(), 0, 3)
    ) %>%
    # Aplicar l√≠mites realistas
    mutate(
      temp_media_c = pmax(pmin(temp_media_c, 45), 0),
      humedad_media_pct = pmax(pmin(humedad_media_pct, 100), 20),
      vel_viento_media_ms = pmax(vel_viento_media_ms, 0),
      dir_viento_grados = ((dir_viento_grados %% 360) + 360) %% 360,
      presion_maxima_hpa = pmax(pmin(presion_maxima_hpa, 1040), 980)
    )
  
  log_info("Datos meteorol√≥gicos generados: {nrow(datos_meteo)} horas")
  log_info("Rango temperaturas: {round(min(datos_meteo$temp_media_c), 1)}¬∞C - {round(max(datos_meteo$temp_media_c), 1)}¬∞C")
  
  return(datos_meteo)
}

# 3. FUNCI√ìN PARA OBTENER DATOS METEOROL√ìGICOS DE AEMET ----
obtener_meteo_aemet <- function(horas_futuras = 40) {

  log_info("Intentando obtener predicciones AEMET para pr√≥ximas {horas_futuras} horas...")

  tryCatch({
    # Intentar cargar predicciones AEMET si existen
    if (file.exists("data/realtime/prediccion_meteo_latest.rds")) {
      datos_aemet <- readRDS("data/realtime/prediccion_meteo_latest.rds")
      log_info("‚úÖ Datos AEMET cargados desde archivo: {nrow(datos_aemet)} registros")

      # Filtrar datos AEMET desde la pr√≥xima hora (zona horaria Madrid)
      hora_actual_madrid <- with_tz(Sys.time(), "Europe/Madrid")
      hora_actual_madrid <- floor_date(hora_actual_madrid, "hour")
      proxima_hora_madrid <- hora_actual_madrid + hours(1)

      datos_ajustados <- datos_aemet %>%
        mutate(
          fecha_hora = timestamp,
          fecha = as.Date(timestamp),
          hora = hour(timestamp),
          dia_a√±o = yday(timestamp),
          # Mapear nombres de columnas AEMET al formato esperado
          humedad_media_pct = humedad_relativa_pct,
          presion_maxima_hpa = presion_hpa,
          vel_viento_media_ms = velocidad_viento_ms
          # dir_viento_grados ya existe
        ) %>%
        filter(timestamp >= proxima_hora_madrid) %>%
        slice_head(n = horas_futuras)

      log_info("üìÖ Predicciones desde pr√≥xima hora Madrid: {min(datos_ajustados$fecha_hora)} a {max(datos_ajustados$fecha_hora)}")
      log_info("‚è∞ Hora actual Madrid: {as.character(hora_actual_madrid)} ‚Üí Pr√≥xima hora: {as.character(proxima_hora_madrid)}")

      if (nrow(datos_ajustados) >= horas_futuras * 0.8) {  # Al menos 80% de los datos
        log_success("‚úÖ Usando predicciones AEMET reales (fechas originales)")
        return(datos_ajustados)
      }
    }

    # Si no hay datos AEMET, usar fallback realista
    log_warn("‚ö†Ô∏è Datos AEMET no disponibles, usando fallback realista")

  }, error = function(e) {
    log_error("‚ùå Error cargando AEMET: {e$message}")
    log_warn("‚ö†Ô∏è Usando fallback realista")
  })

  # FALLBACK: Usar la funci√≥n de generaci√≥n existente (ya corregida con temperaturas realistas)
  return(generar_meteo_futuro(horas_futuras))
}

# 3b. FUNCI√ìN PARA CREAR VARIABLES DERIVADAS PARA PREDICCI√ìN (RANGER ICA + UTM + FASE 3) ----
crear_variables_derivadas_prediccion <- function(datos, datos_auxiliares = NULL) {
  log_info("Creando variables derivadas para predicci√≥n (formato RANGER ICA + UTM + FASE 3)...")

  # Centro de Madrid en UTM Zone 30N (Puerta del Sol)
  MADRID_CENTRO_UTM_X <- 440000  # metros
  MADRID_CENTRO_UTM_Y <- 4474000  # metros

  datos_enriquecidos <- datos %>%
    mutate(
      # Mapear contaminante a id_magnitud (necesario para JOIN con baseline)
      id_magnitud = case_when(
        contaminante == "Di√≥xido de Nitr√≥geno" ~ 8L,
        contaminante == "Part√≠culas < 10 ¬µm" ~ 9L,
        contaminante == "Part√≠culas < 2.5 ¬µm" ~ 10L,
        contaminante == "Ozono" ~ 14L,
        contaminante == "Di√≥xido de Azufre" ~ 1L,
        TRUE ~ NA_integer_
      )) %>%
    mutate(
      # VARIABLES ESPACIALES UTM: Convertir lat/lon a UTM Zone 30N (EPSG:25830)
      utm_x = if("lon" %in% names(.) && "lat" %in% names(.)) {
        # Conversi√≥n con sf (si est√° disponible)
        coords_wgs84_x <- st_as_sf(data.frame(lon = lon, lat = lat),
                                    coords = c("lon", "lat"), crs = 4326)
        coords_utm_x <- st_transform(coords_wgs84_x, 25830)
        st_coordinates(coords_utm_x)[,1]
      } else {
        MADRID_CENTRO_UTM_X  # Default
      },

      utm_y = if("lon" %in% names(.) && "lat" %in% names(.)) {
        coords_wgs84_y <- st_as_sf(data.frame(lon = lon, lat = lat),
                                    coords = c("lon", "lat"), crs = 4326)
        coords_utm_y <- st_transform(coords_wgs84_y, 25830)
        st_coordinates(coords_utm_y)[,2]
      } else {
        MADRID_CENTRO_UTM_Y  # Default
      },

      # Variables espaciales derivadas
      dist_centro_madrid = sqrt((utm_x - MADRID_CENTRO_UTM_X)^2 +
                               (utm_y - MADRID_CENTRO_UTM_Y)^2) / 1000,  # km
      utm_x_norm = (utm_x - MADRID_CENTRO_UTM_X) / 10000,  # decenas de km
      utm_y_norm = (utm_y - MADRID_CENTRO_UTM_Y) / 10000,

      # Variables temporales (igual que entrenamiento ranger - sin c√≠clicas)
      a√±o = year(fecha_hora),
      mes = month(fecha_hora),
      dia = day(fecha_hora),
      dia_a√±o = yday(fecha_hora),
      dia_semana = wday(fecha_hora) - 1,  # 0-6 (Domingo=0)
      fin_semana = ifelse(dia_semana %in% c(0, 6), 1, 0),  # 0=Domingo, 6=S√°bado

      # Variables meteorol√≥gicas derivadas (CORREGIDO 2025-10-11 - CR√çTICO: igual que entrenamiento)
      # Temperatura: m√∫ltiples transformaciones para capturar no-linealidades
      temp_abs = abs(temp_media_c),
      temp_sign = sign(temp_media_c),
      temp_sq = temp_media_c^2,
      temp_sq_signed = temp_media_c * abs(temp_media_c),
      temp_cubic = temp_media_c^3,

      # Ratios temperatura-humedad (CORREGIDO: offset para evitar divisiones problem√°ticas)
      temp_hum_ratio = (temp_media_c + 20) / (humedad_media_pct + 1),
      temp_hum_ratio_inv = humedad_media_pct / (abs(temp_media_c) + 1),

      # D√©ficit de Presi√≥n de Vapor (VPD) - f√≠sicamente robusto
      e_sat = 6.112 * exp((17.67 * temp_media_c) / (temp_media_c + 243.5)),
      e_actual = e_sat * (humedad_media_pct / 100),
      vpd = e_sat - e_actual,

      # Componentes del viento (CR√çTICO: usar direcci√≥n si existe)
      dir_viento = ifelse("dir_viento_grados" %in% names(.), dir_viento_grados, 180),
      viento_x = vel_viento_media_ms * cos(dir_viento * pi / 180),
      viento_y = vel_viento_media_ms * sin(dir_viento * pi / 180),

      # Variables opcionales que pueden venir de expansi√≥n meteorol√≥gica
      presion_media_hpa = ifelse("presion_media_hpa" %in% names(.), presion_media_hpa,
                                  ifelse("presion_maxima_hpa" %in% names(.), presion_maxima_hpa, 1013)),
      humedad_maxima_pct = ifelse("humedad_maxima_pct" %in% names(.), humedad_maxima_pct,
                                   humedad_media_pct * 1.15),
      humedad_minima_pct = ifelse("humedad_minima_pct" %in% names(.), humedad_minima_pct,
                                   humedad_media_pct * 0.85),
      temp_maxima_c = ifelse("temp_maxima_c" %in% names(.), temp_maxima_c,
                             temp_media_c + 6),
      temp_minima_c = ifelse("temp_minima_c" %in% names(.), temp_minima_c,
                             temp_media_c - 6),
      presion_maxima_hpa = ifelse("presion_maxima_hpa" %in% names(.), presion_maxima_hpa,
                                  presion_media_hpa + 3),
      presion_minima_hpa = ifelse("presion_minima_hpa" %in% names(.), presion_minima_hpa,
                                  presion_media_hpa - 3),

      # Variables derivadas adicionales (si las columnas base existen)
      temp_range = ifelse(exists("temp_maxima_c") & exists("temp_minima_c"),
                         temp_maxima_c - temp_minima_c, 12),
      presion_diff = ifelse(exists("presion_maxima_hpa") & exists("presion_minima_hpa"),
                           presion_maxima_hpa - presion_minima_hpa, 6),
      humedad_diff = ifelse(exists("humedad_maxima_pct") & exists("humedad_minima_pct"),
                           humedad_maxima_pct - humedad_minima_pct, 30),

      # ==================== BASELINE Y TIPO D√çA (SIN LAGS) ====================
      # CORRECCI√ìN: Modelo reentrenado SIN lags cortos
      # Solo agregamos tipo_dia_num, el baseline se agrega despu√©s

      # TIPO DE D√çA (mejorado para capturar patrones semanales)
      tipo_dia_num = case_when(
        dia_semana %in% c(0, 6) ~ 0,      # Fin de semana
        dia_semana == 1 ~ 1,              # Lunes
        dia_semana == 5 ~ 2,              # Viernes
        TRUE ~ 3                          # Martes-Jueves
      )
    )

  # ==================== JOIN CON BASELINE ESTACIONAL (SOLO PROMEDIO) ====================

  if(!is.null(datos_auxiliares) && !is.null(datos_auxiliares$baseline)) {

    log_info("Uniendo con baseline estacional (solo promedio_5y)...")

    datos_con_baseline <- datos_enriquecidos %>%
      left_join(
        datos_auxiliares$baseline %>% select(id_magnitud, mes, dia_mes, hora, promedio_5y),
        by = c("id_magnitud", "mes", "dia" = "dia_mes", "hora"),
        relationship = "many-to-one"
      )

    log_info("‚úÖ Baseline estacional agregado (promedio_5y)")

    datos_enriquecidos <- datos_con_baseline

  } else {
    # Si no hay baseline, agregar con NA
    datos_enriquecidos <- datos_enriquecidos %>%
      mutate(promedio_5y = NA_real_)

    log_warn("‚ö†Ô∏è Baseline no disponible, usando NA")
  }

  n_variables <- ncol(datos_enriquecidos) - 1  # -1 por contaminante
  log_info("Variables derivadas creadas: {n_variables} predictores totales (incluye FASE 3)")

  return(datos_enriquecidos)
}

# 3c. FUNCI√ìN PARA CARGAR BASELINE ESTACIONAL Y DATOS HIST√ìRICOS ----
cargar_datos_auxiliares <- function() {

  log_info("Cargando datos auxiliares (baseline + hist√≥ricos)...")

  # Cargar credenciales BD
  readRenviron('.Renviron')

  library(DBI)
  library(RPostgres)

  con <- dbConnect(
    RPostgres::Postgres(),
    host = Sys.getenv("DB_HOST"),
    port = Sys.getenv("DB_PORT"),
    dbname = Sys.getenv("DB_NAME"),
    user = Sys.getenv("DB_USER"),
    password = Sys.getenv("DB_PASSWORD")
  )

  # Cargar baseline estacional
  baseline_estacional <- dbGetQuery(con, "
    SELECT
      id_magnitud,
      mes,
      dia_mes,
      hora,
      promedio_5y,
      p10,
      p90
    FROM dim_baseline_estacional
  ")

  log_success("‚úÖ Baseline estacional cargado: {format(nrow(baseline_estacional), big.mark=',')} registros")

  # Cargar datos hist√≥ricos recientes (√∫ltimas 2 semanas para calcular lags)
  datos_historicos <- dbGetQuery(con, "
    SELECT
      fm.fecha_hora,
      fm.id_magnitud,
      fm.id_estacion,
      fm.valor_medido as valor_medio,
      dm.descripcion as contaminante
    FROM fact_mediciones fm
    JOIN dim_magnitudes dm ON fm.id_magnitud = dm.id_magnitud
    WHERE fm.fecha_hora >= NOW() - INTERVAL '2 weeks'
      AND fm.valor_medido IS NOT NULL
      AND dm.descripcion IN (
        'Di√≥xido de Nitr√≥geno',
        'Part√≠culas < 10 ¬µm',
        'Part√≠culas < 2.5 ¬µm',
        'Ozono',
        'Di√≥xido de Azufre'
      )
    ORDER BY fm.fecha_hora DESC
  ")

  log_success("‚úÖ Datos hist√≥ricos cargados: {format(nrow(datos_historicos), big.mark=',')} registros")

  dbDisconnect(con)

  return(list(
    baseline = baseline_estacional,
    historicos = datos_historicos
  ))
}

# 4. FUNCI√ìN PARA GENERAR PREDICCIONES POR ESTACI√ìN ----
generar_predicciones_estaciones <- function(datos_meteo, datos_auxiliares, archivo_modelos = "models/ranger_ica_todos.rds") {

  log_info("Generando predicciones para estaciones de Madrid...")

  # Registrar memoria inicial
  memoria_inicial_mb <- as.numeric(gc()[2,2])
  log_info("üíæ Memoria en uso inicial: {round(memoria_inicial_mb, 1)} MB")

  # Obtener lista de archivos de modelos individuales (modo optimizado memoria)
  archivos_modelos <- list.files("models/", pattern = "^ranger_ica_.*\\.rds$", full.names = TRUE)
  archivos_modelos <- archivos_modelos[!grepl("todos|metricas", archivos_modelos)]

  if(length(archivos_modelos) < 5) {
    log_error("Solo se encontraron {length(archivos_modelos)} modelos (se esperaban 5)")
    return(NULL)
  }

  log_info("üì¶ Modo optimizado memoria: cargar modelos UNO POR UNO")
  log_info("Modelos encontrados: {length(archivos_modelos)}")
  
  # Coordenadas de estaciones principales de Madrid
  estaciones <- data.frame(
    id_estacion = c(4, 8, 11, 16, 17, 18, 27, 35, 36, 38, 39, 40, 47, 48, 49, 50),
    nombre_estacion = c(
      "Pza. de Espa√±a", "Escuelas Aguirre", "Av. Ram√≥n y Cajal", "Arturo Soria",
      "Villaverde Alto", "Farolillo", "Barajas Pueblo", "Pza. del Carmen",
      "Moratalaz", "Cuatro Caminos", "Barrio del Pilar", "Vallecas",
      "Mendez Alvaro", "Castellana", "Retiro", "Pza. Castilla"
    ),
    lat = c(40.4238, 40.4213, 40.4514, 40.4405, 40.3479, 40.3748, 40.4756, 40.4192,
            40.4077, 40.4459, 40.4773, 40.3943, 40.3980, 40.4407, 40.4152, 40.4656),
    lon = c(-3.7122, -3.6958, -3.6774, -3.6394, -3.7215, -3.7336, -3.5935, -3.7026,
            -3.6453, -3.7097, -3.7137, -3.6458, -3.6862, -3.6889, -3.6823, -3.6951)
  )

  # Generar predicciones UNO POR UNO (modo optimizado memoria)
  predicciones_finales <- list()

  for(i in seq_along(archivos_modelos)) {
    archivo <- archivos_modelos[i]

    # Extraer nombre del contaminante
    nombre_base <- basename(archivo)
    nombre_contaminante <- gsub("^ranger_ica_", "", nombre_base)
    nombre_contaminante <- gsub("\\.rds$", "", nombre_contaminante)
    nombre_contaminante <- gsub("_", " ", nombre_contaminante)

    # Mapear a nombre oficial
    nombre_contaminante <- case_when(
      grepl("Di.*xido.*de.*Nitr", nombre_contaminante, ignore.case = TRUE) ~ "Di√≥xido de Nitr√≥geno",
      grepl("Part.*culas.*10", nombre_contaminante, ignore.case = TRUE) ~ "Part√≠culas < 10 ¬µm",
      grepl("Part.*culas.*2.*5", nombre_contaminante, ignore.case = TRUE) ~ "Part√≠culas < 2.5 ¬µm",
      grepl("Ozono", nombre_contaminante, ignore.case = TRUE) ~ "Ozono",
      grepl("Di.*xido.*de.*Azufre", nombre_contaminante, ignore.case = TRUE) ~ "Di√≥xido de Azufre",
      TRUE ~ nombre_contaminante
    )

    log_info("üì¶ [{i}/{length(archivos_modelos)}] Cargando modelo: {nombre_contaminante}...")

    tryCatch({
      # CARGAR SOLO ESTE MODELO
      modelo_caret <- readRDS(archivo)

      memoria_modelo_mb <- as.numeric(gc()[2,2])
      log_info("üíæ Memoria despu√©s de cargar modelo: {round(memoria_modelo_mb, 1)} MB")

      # Crear combinaciones solo para este contaminante
      combinaciones <- expand.grid(
        fecha_hora = datos_meteo$fecha_hora,
        id_estacion = estaciones$id_estacion,
        stringsAsFactors = FALSE
      ) %>%
        mutate(contaminante = nombre_contaminante) %>%
        left_join(datos_meteo, by = "fecha_hora") %>%
        left_join(estaciones, by = "id_estacion") %>%
        crear_variables_derivadas_prediccion(datos_auxiliares)

      log_info("  Combinaciones: {nrow(combinaciones)} registros")

      # Extraer m√©tricas del modelo
      metricas_modelo <- modelo_caret$results %>%
        filter(mtry == modelo_caret$bestTune$mtry,
               splitrule == modelo_caret$bestTune$splitrule,
               min.node.size == modelo_caret$bestTune$min.node.size)

      rmse_modelo <- metricas_modelo$RMSE[1]
      r2_modelo <- metricas_modelo$Rsquared[1]

      # PREDICCIONES (usar wrapper de caret)
      predicciones <- predict(modelo_caret, newdata = combinaciones)

      # Agregar predicciones
      datos_con_predicciones <- combinaciones %>%
        mutate(
          prediccion = predicciones,
          rmse_modelo = rmse_modelo,
          r2_modelo = r2_modelo
        )

      predicciones_finales[[nombre_contaminante]] <- datos_con_predicciones

      log_success("‚úì {nombre_contaminante}: {nrow(datos_con_predicciones)} predicciones")
      log_info("  Rango: {round(min(predicciones), 1)} - {round(max(predicciones), 1)} ¬µg/m¬≥")
      log_info("  Modelo: RMSE={round(rmse_modelo, 2)}, R¬≤={round(r2_modelo, 3)}")

      # LIBERAR MEMORIA: eliminar modelo despu√©s de usarlo
      rm(modelo_caret, combinaciones, predicciones, datos_con_predicciones)
      gc_resultado <- gc()
      memoria_despues_mb <- as.numeric(gc_resultado[2,2])
      log_info("üíæ Memoria despu√©s de liberar modelo: {round(memoria_despues_mb, 1)} MB")

    }, error = function(e) {
      log_error("‚ùå Error con {nombre_contaminante}: {e$message}")
    })
  }
  
  # Combinar todas las predicciones
  if(length(predicciones_finales) == 0) {
    log_error("No se generaron predicciones")
    return(NULL)
  }
  
  resultado_completo <- bind_rows(predicciones_finales)
  
  # Convertir a objeto espacial
  resultado_sf <- resultado_completo %>%
    st_as_sf(coords = c("lon", "lat"), crs = 4326) %>%
    mutate(timestamp_prediccion = Sys.time())
  
  log_success("‚úì Predicciones horarias completadas: {nrow(resultado_sf)} registros")
  
  return(resultado_sf)
}

# 5. FUNCI√ìN PRINCIPAL ----
generar_predicciones_40h <- function(horas = 40) {

  log_info("=== GENERANDO PREDICCIONES PR√ìXIMAS {horas} HORAS ===")

  # Paso 1: Obtener datos meteorol√≥gicos de AEMET (con fallback)
  datos_meteo <- obtener_meteo_aemet(horas)

  if(is.null(datos_meteo)) {
    log_error("No se pudieron generar datos meteorol√≥gicos")
    return(NULL)
  }

  # Paso 1b: Cargar baseline estacional y datos hist√≥ricos (FASE 3)
  log_info("FASE 3: Cargando baseline estacional y datos hist√≥ricos...")
  datos_auxiliares <- cargar_datos_auxiliares()

  # Paso 2: Generar predicciones para estaciones
  predicciones <- generar_predicciones_estaciones(datos_meteo, datos_auxiliares)
  
  if(is.null(predicciones)) {
    log_error("No se pudieron generar predicciones")
    return(NULL)
  }
  
  # Paso 3: Guardar resultados
  archivo_salida <- "output/predicciones_40h_latest.rds"
  saveRDS(predicciones, archivo_salida)
  
  # Tambi√©n guardar datos meteorol√≥gicos para gr√°ficos
  archivo_meteo <- "output/meteo_40h_latest.rds"
  saveRDS(datos_meteo, archivo_meteo)
  
  log_success("‚úì PREDICCIONES 40H COMPLETADAS")
  log_info("  Total registros: {nrow(predicciones)}")
  log_info("  Horas: {horas}")
  log_info("  Estaciones: {length(unique(predicciones$id_estacion))}")
  log_info("  Contaminantes: {length(unique(predicciones$contaminante))}")
  log_info("  Archivo predicciones: {archivo_salida}")
  log_info("  Archivo meteorolog√≠a: {archivo_meteo}")
  
  return(predicciones)
}

# 6. FUNCI√ìN DE TEST ----
test_predicciones_40h <- function() {
  log_info("=== TEST PREDICCIONES 40H ===")
  
  resultado <- generar_predicciones_40h(40)
  
  if(is.null(resultado)) {
    log_error("‚ùå Test fall√≥")
    return(FALSE)
  }
  
  # Validaciones
  validaciones <- list(
    registros_totales = nrow(resultado),
    horas_unicas = length(unique(resultado$fecha_hora)),
    estaciones_unicas = length(unique(resultado$id_estacion)),
    contaminantes_unicos = length(unique(resultado$contaminante)),
    rango_predicciones = c(min(resultado$prediccion), max(resultado$prediccion)),
    valores_negativos = sum(resultado$prediccion < 0),
    valores_na = sum(is.na(resultado$prediccion))
  )
  
  log_success("‚úì Test predicciones 40h exitoso")
  log_info("  Registros totales: {validaciones$registros_totales}")
  log_info("  Horas √∫nicas: {validaciones$horas_unicas}")
  log_info("  Estaciones √∫nicas: {validaciones$estaciones_unicas}")
  log_info("  Contaminantes √∫nicos: {validaciones$contaminantes_unicos}")
  log_info("  Rango predicciones: {round(validaciones$rango_predicciones[1], 1)} - {round(validaciones$rango_predicciones[2], 1)}")
  log_info("  Valores negativos: {validaciones$valores_negativos}")
  log_info("  Valores NA: {validaciones$valores_na}")
  
  return(TRUE)
}

# Ejecutar test autom√°ticamente
if(interactive() == FALSE) {
  test_predicciones_40h()
}